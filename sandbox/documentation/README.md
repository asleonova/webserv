# WEBSERV

## PIPELINE проекта и бэклог

до 30/05/2021 (ядро):
1. Создаем два объекта сервисной конфигурации с константными настройками.
2. Делаем bind/listen для каждого объекта сервера (+неблокирующий fd ls) -> получаем список fd для акцепта связанных с серверами
3. Наполняем наборы на read/write
4. Заходим в основной цикл с селектом
5. Если есть соединения - создаем объект сессии (соединения) со своими буфферами и устанавливаем режим "чтения" для сессии
6. Наполняем набор на чтение для созданной сессии в цикле
7. После каждого чтения после селекта парсим буфер - если есть искомая строка - переключаем на режим "отправки" для сессии
8. В режиме отправки просто отправляем константную стрингу

## 30/05/2021:
 - сервер встает по конфигу на обозначенные ip/addr // принимает и обрабатывает запросы
 - при успешном парсинге _isOK == true
 - сервер отдает базовую страницу + favicon.ico

## 31/05/2021:
 - добавил clientHTTP в песочницу /sandbox/clientHTTP/loader.cpp который отправляет запрос на указанный сервер и сохраняет ответ в два файла
 - работа над подготовкой ответов

## 01/06/2021:
 - добавлена документация /documentation (rfc + кейсы + примеры)
 - добавлена структура ответа <Response> (код ответа/фраза ответа/мапа заголовков/тело) + методы (вставка заголовков/формирование ответа)
 - работа над структурой отдачи стандартных ошибок <ErrorReport>

## 02/06/2021:
 - добавил перечисление всех кодов вывода 
 - добавил функцию вывода стандартной ошибки (тодо: добавить авторские страницы)
 - добавил формирование заголовкой в getStrForAnswer в класс Response: длинна сообщения + причина по коду ответа

## 03/06/2021:
 - в ReturnErrorPage добавлено перечисление методов при ошибке MethodNotAllowed (принимает std::vector<Method> *allowedMethod)
 - написал класс HandleRequest (отлов ошибок и подсование собщений об ошибках) 10h

## ТОДО (до 3 июня):
- в настоящий момент перепишу Request (парсинг будет вызываться только при окончательном запросе а не текущая лапша) + сделаю отладку на терминал
- нужно уже тестировать на тестере (как только обработчик запросов будет +/- готов)
- нужно создать класс который получая объекты ServConf  (вектор) и Request (заполненную структуру) готовит ответ возвращает std::string (которую я отдам клиенту)


# СТРУКТУРА ПРОЕКТА (СТРУКТУРЫ/КЛАССЫ):

Request			-> хранит в себе распарсенный запрос
HandleRequest	-> управляет распарсенным запросом (конструктор принимает распарсенный запрос):
					Работает с:
					- ServerConf
					- Request
					Отдает Response
Response		-> ответ (старлайн+заголовки+тело) <- наполняется через RequestHandler

## отдаем запрос
Request cur_request;
cur_request.syntax(std::string(buf, read_res).c_str());

## готовим ответ (вот на этой функции сейчас нужно сосредоточится)
Response response = request_handler.handleRequest(cur_request, itListSess->server_conf);

важно:
 - выставить код ответа (расшифровку кода буду давать при подготовки ответа)
 - выставить заголовки правильно (дату буду выставлять при отсылке запроса)
 - залить теле при ответе в std::stirng response.body

## отдаем ответ (в основном ядре цикла)
itListSess->answer_buf = response.getStrForAnswer(); // собираем текстовый ответ который отдается клиенту

